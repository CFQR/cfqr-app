// @flow
import cfqrData from 'cfqr-data';

const getQuestionsInfo = (elements: Object) => {
  let questions = {};
  if (!elements) {
    return questions;
  }
  elements.forEach(element => {
    if (element.id) {
      questions = Object.assign(questions, {
        [element.id]: element
      });
    }
    if (element.content) {
      const subContentQuestionsElements = getQuestionsInfo(element.content);
      questions = Object.assign(questions, subContentQuestionsElements);
    }
    if (element.questions) {
      const subElementQuestions = getQuestionsInfo(element.questions);
      Object.keys(subElementQuestions).forEach(key => {
        subElementQuestions[key].answers = element.answers;
      });
      questions = Object.assign(questions, subElementQuestions);
    }
  });
  return questions;
};

const getQuestionsIds = (elements: Object) => {
  const questionsInfo = getQuestionsInfo(elements);
  return Object.keys(questionsInfo).map(key => questionsInfo[key].id);
};

const getQuestionsFromData = () => {
  const cfqrQuestions = {};
  Object.keys(cfqrData.elements).forEach(qstKey => {
    cfqrQuestions[qstKey] = getQuestionsIds(cfqrData.elements[qstKey]);
  });
  return cfqrQuestions;
};

const validateQuestionnaire = (state: Object) => {
  if (state.questions.length > Object.keys(state.results).length) {
    return false;
  }
  return true;
};

const formatQuestionnaire = (state: Object) => {
  const questionnaireType = state.type;
  const questionsScores = cfqrData.scores[questionnaireType];
  const doc = {};
  // doc._id: autogenerated
  // doc.createdAt: autogenerated
  // doc.updatedAt: autogenerated
  doc.appVersion = process.env.APP_VERSION;
  doc.dataVersion = cfqrData.version;
  doc.type = state.type;
  doc.patient = state.patient || null;
  doc.answers = {};
  const answers = state.results;
  Object.keys(answers).forEach(qstKey => {
    const answer = (typeof answers[qstKey].answer !== 'undefined') ? answers[qstKey].answer : null;
    if (questionsScores[qstKey]) {
      // question w/ score
      // 'question-1': 2
      doc.answers[qstKey] = answer;
    } else {
      // open question
      // patient: 'patient name'
      doc[qstKey] = answer;
    }
  });
  return doc;
};

const findMissingAnswers = (questionnaire: Object) =>
  questionnaire.questions.filter(questionId => !questionnaire.results[questionId]);

const calculateScore = (questionnaire: Object) => {
  const { answers, type } = questionnaire;
  const questionsScores = cfqrData.scores[type];
  if (!questionsScores) {
    return {};
  }

  const scoresByType = {};
  Object.keys(questionsScores).forEach(questionId => {
    const question = questionsScores[questionId];
    const questionType = question.type;
    const answer = answers[questionId];
    const score = question.score[answer];

    if (!scoresByType[questionType]) {
      scoresByType[questionType] = {
        total: 0,
        count: 0
      };
    }
    if (score >= 0) {
      // -1 means "doesn't apply"
      scoresByType[questionType].total += score;
      scoresByType[questionType].count += 1;
    }
  });

  const finalScores = {};
  Object.keys(scoresByType).forEach(scoreTypeKey => {
    const scoreType = scoresByType[scoreTypeKey];
    finalScores[scoreTypeKey] = ((scoreType.total - scoreType.count) / (scoreType.count * 3)) * 100;
    if (isNaN(finalScores[scoreTypeKey])) {
      finalScores[scoreTypeKey] = 0;
    }
    finalScores[scoreTypeKey] = +finalScores[scoreTypeKey].toFixed(2);
  });
  return finalScores;
};

export {
  calculateScore,
  getQuestionsIds,
  getQuestionsInfo,
  getQuestionsFromData,
  validateQuestionnaire,
  formatQuestionnaire,
  findMissingAnswers
};
